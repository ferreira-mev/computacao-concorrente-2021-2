% !TEX program = xelatex

\documentclass{article}

\input{personaldata.tex} % (so my full name and DRE won't be on GitHub)

\usepackage[brazil]{babel}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{xurl}  % linebreaks at any character

\usepackage{graphicx}
\graphicspath{ {..} }

\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    citecolor=blue,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue
}

\urlstyle{same}

\usepackage{listings}

\lstset{
  basicstyle=\ttfamily,
  breaklines=true,
  breakatwhitespace=false
} 

\usepackage[style=numeric, sorting=nyt]{biblatex}
\addbibresource{EduardaFerreira-CompConc-trab-relatorio.bib}

\usepackage{amsmath, amsfonts}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}

\begin{document}

\begin{center}
  \begin{Large}
    \textbf{Trabalho de Implementação}
  \end{Large}

  \vspace{8pt}

  \begin{large}
    \textbf{Computação Concorrente (MAB-117) — 2021/2}
  \end{large}

  \vspace{8pt}

  \begin{Large}
    \textbf{Implementação paralela do método do trapézio para integração numérica}
  \end{Large}

  \vspace{12pt}

  \begin{large}
    \textbf{\fullname\textsuperscript{1}}  % as defined in personaldata.tex

    \vspace{5pt}

    \textsuperscript{1}Graduação em Matemática Aplicada, IM, UFRJ; DRE \DRE % as defined in personaldata.tex
  \end{large}

\end{center}

  \section{Descrição do problema} \label{descr}

  Dentre os temas sugeridos, chamou-me atenção a integração numérica, por se tratar de um assunto que eu já havia estudado no curso de Computação Científica I do prof.\ Bernardo Costa\cite{cci}. Trata-se do problema de, dadas uma função matemática e uma região de integração, calcular uma aproximação do valor da integral da função nessa região por meio de um algoritmo, sem a obtenção de uma primitiva da função em estudo. Para fins deste trabalho, restringi-me a funções reais de uma variável real, da forma $f: \R \to \R$, e intervalos reais de integração $[a, b] \in \R$, com $-\infty < a < b < \infty$.

  A integração numérica é de interesse sobretudo ao lidar com funções cujas primitivas sejam desconhecidas, bem como para possibilitar a incorporação de uma etapa de integração num programa computacional de forma mais simples e menos computacionalmente custosa do que com o uso de um sistema capaz de realizar integração simbólica.
  
  Na disciplina de CC I, fizemos tanto um estudo teórico/analítico de alguns algoritmos para aproximação numérica de integrais quanto uma implementação prática desses algoritmos, em sua forma sequencial, em linguagem Python; ambos incluíram o estudo dos erros de aproximação (analítico) e numérico. 
  
  Um dos métodos estudados foi o do trapézio, que recebe esse nome devido a sua interpretação geométrica. No caso de funções reais de uma variável real, sabe-se que a integral definida de $f$ em $[a, b]$ fornece a ``área com sinal'' sob o gráfico da função no intervalo de integração, i.e., a medida da área entre o eixo $x$ e o lugar geométrico dos pontos $(x, f(x))$, $a \leq x \leq b$, multiplicada por -1 nas regiões onde $f(x) < 0$, e novamente multiplicada por -1 se $b < a$. 
  
  No método do trapézio, particiona-se $[a, b]$ em $n \in \N \setminus \{0\}$ subintervalos $I_i = [x_i, x_{i+1}]$ e aproxima-se o valor da integral em cada subintervalo por
  \begin{equation} \label{trapterm}
    \frac{b-a}{n} \frac{f(x_i) + f(x_{i+1})}{2} =: h \frac{f(x_i) + f(x_{i+1})}{2},
  \end{equation}\noindent
  onde $h$ é definido como o comprimento de cada subintervalo. Quando $f(x) > 0$ para todo $x \in I_i$, isso equivale à área de um trapézio de vértices $(x_i, 0)$, $(x_{i+1}, 0)$, $(x_i, f(x_i))$ e $(x_{i+1}, f(x_{i+1}))$. % imagem?

  Desse modo, dados $f: \R \to \R$ e $[a, b] \in \R$ e fixado um valor de $n \in \N \setminus \{0\}$, o método do trapézio nos fornece a aproximação
  \begin{equation} \label{trapformula}
    \int_a^b f(x) dx \approx \sum_{i=0}^{n-1} \frac{b-a}{n} \frac{f(x_i) + f(x_{i+1})}{2} = h \sum_{i=0}^{n-1} \frac{f(x_i) + f(x_{i+1})}{2}.
  \end{equation}

  Conforme seria intuitivamente esperado, a precisão do método será tanto maior quanto for pequeno o valor de $h$. Sob a suposição que de $f$ seja duas vezes diferenciável, demonstra-se\cite{cci} que o erro total de aproximação -- aquele que é analiticamente esperado devido ao próprio método, independentemente da precisão da representação computacional com que se trabalhe -- é da ordem de $h^2$; mais especificamente, ele é dado por
  $$ e^T_h := \frac{f'(b) -f'(a)}{12} h^2 + o(h^2), $$ \noindent
  onde por $o(h^2)$ denota-se termos que, divididos por $h^2$, tendem a 0 quando $h \to 0$. (Vale ressaltar que, como estar-se-ia sempre trabalhando com $h \ll 1$, o que é relevante é o comportamento do erro quando $h$ é próximo de 0, e a magnitude dos termos com fatores $h^k$ será menor para $k$ maior.)

  Observando \eqref{trapformula}, é possível constatar que esse algoritmo pode ser facilmente tornado paralelo, dado que os termos calculados para cada índice $i$ são independentes dos demais (exceto na medida em que, para $i < n - 1$, os valores de $f'(x_{i+1})$ reparecem como $f'(x_i)$ no termo seguinte, de modo a beneficiarem-se de alguma forma de armazenamento do valor obtido no termo anterior, numa lógica análoga à de um cache simples; entretanto, isso é uma possível otimização, e não uma dependência estrita).
  
  Uma vez que, numa implementação sequencial, os $n$ termos de \eqref{trapformula} seriam calculados um após o outro, pode-se esperar um ganho de perfomance ao dividi-los entre múltiplas threads de execução paralela num processador multicore, sobretudo se essa divisão for feita de modo a reduzir a quantidade de cálculos de $f'(x_i)$, alocando blocos de subintervalos consecutivos para a mesma thread.

  \section{Projeto e implementação da solução concorrente}

  Como no caso de outros algoritmos paralelos estudados na disciplina, o cálculo dos valores de \eqref{trapterm} para diferentes subintervalos pode ser distribuído entre as threads de diversas formas, dentre as quais destacam-se mais imediatamente as divisões ``em listras'' ou ``em blocos''. Por ``em listras'', quero dizer que, se há $t$ threads, o subintervalo de índice 0 caberia à thread de índice 0, $I_1$ à thread 1, ..., $I_{t - 1}$ à $t-1$, $I_{t}$ à thread 0 outra vez, $I_{t + 1}$ à $1$, e assim sucessivamente; ou seja, o subintervalo $i$ seria alocado para a thread $i \% t$.

  Já a divisão que chamo de ``em blocos'' corresponderia a subdividir os $n$ subintervalos em $t$ grupos, com os $t - 1$ primeiros contendo $m := \lfloor n/t \rfloor$ subintervalos, com índices $ k m \leq i < (k+1) m$ para o grupo $k$, $0 \leq k \leq t-2$; e o último contendo os subintervalos de índices $(t-1)m \leq k \leq n - 1$. (Conforme discutido em aula, essa solução não garante um balanceamento perfeito se a quantidade $n$ de subintervalos não é divisível pela quantidade $t$ de threads; contudo, nesse caso, esse balanceamento é impossível, e essa é uma divisão simples que se aproxima bastante de uma distribuição equilibrada para $n \gg t$.)

  Optei por esta última divisão para reduzir a quantidade de operações efetuadas alocando subintervalos com índices consecutivos para a mesma thread, assim permitindo que os valores de $x_{i+1}$ e $f'(x_{i+1})$ computados numa iteração sejam mantidos na memória e reproveitados como $x_i$ e $f'(x_i)$ na iteração seguinte (vide seção \ref{descr}).

  % abaixo apenas uns rascunhos p/ não esquecer

  O somatório dos valores de \eqref{trapterm} computados por cada thread é somado e retornado à thread principal, que agrega essas somas parciais num somatório total correspondente a \eqref{trapformula}.

  Além de $f$ e de $[a, b]$, para fins de avaliação de desempenho 

  Não incluí verificações de cunho matemático, como o pertencimento do intervalo $[a, b]$ ao domínio de $f$, que seriam de implementação complexa e fugiriam ao escopo do trabalho.

  \section{Casos de teste}

  \section{Avaliação de desempenho}

  \section{Discussão}

  \section{Referências bibliográficas}

  \printbibliography

\end{document}